using UnityEngine;
using System.Collections;

public class CoinSpawner : MonoBehaviour
{
    [Header("coin prefab")]
    public GameObject coinPrefab;

    [Header("spawn settings")]
    [Range(0f, 1f)] public float spawnProbability = 0.35f;
    public float minDistance = 4f;
    public float gridSpacing = 5f;
    public LayerMask groundLayer;
    public Vector3 spawnOffset = new Vector3(0f, 0.2f, 0f);

    [Header("coin row settings")]
    [Min(1)] public int coinsPerRow = 4;
    public float distanceBetweenCoins = 2f;
    public float minCurveAmplitude = 0.5f;   // how far left/right at minimum
    public float maxCurveAmplitude = 2f;     // how far left/right at maximum
    [Header("coin orientation")]
    [Tooltip("extra euler rotation applied to each coin")]
    public Vector3 coinRotationOffsetEuler = Vector3.zero;


    [Header("area filter")]
    [Tooltip("children whose name starts with this will be used as spawn areas")]
    public string areaPrefix = "ObstacleArea";

    private bool hasSpawned = false;
    private Transform coinFolder;

    private void OnEnable()
    {
        if (!hasSpawned)
            StartCoroutine(SpawnRoutine());
    }

    private IEnumerator SpawnRoutine()
    {
        hasSpawned = true;

        yield return null; // wait 1 frame so colliders / ground are ready

        if (coinPrefab == null)
        {
            Debug.LogWarning("[CoinSpawner] coinPrefab is not assigned, skipping generation.");
            yield break;
        }

        if (coinFolder == null)
        {
            coinFolder = new GameObject("Coins_AutoGenerated").transform;
            coinFolder.SetParent(transform, false);
        }

        foreach (Transform child in transform)
        {
            if (!child.name.StartsWith(areaPrefix)) continue;
            if (!child.TryGetComponent<BoxCollider>(out var box)) continue;

            GenerateInArea_Local(box);
        }
    }

    private void GenerateInArea_Local(BoxCollider box)
    {
        Vector3 size = box.size;
        Vector3 center = box.center;

        int stepsX = Mathf.Max(1, Mathf.CeilToInt(size.x / gridSpacing));
        int stepsZ = Mathf.Max(1, Mathf.CeilToInt(size.z / gridSpacing));

        Vector3 localMin = center - size * 0.5f;

        for (int x = 0; x < stepsX; x++)
        {
            for (int z = 0; z < stepsZ; z++)
            {
                if (Random.value > spawnProbability)
                    continue;

                float offsetX = (x + 0.5f + Random.Range(-0.4f, 0.4f)) * size.x / stepsX;
                float offsetZ = (z + 0.5f + Random.Range(-0.4f, 0.4f)) * size.z / stepsZ;

                Vector3 localSample = localMin + new Vector3(offsetX, 0f, offsetZ);
                Vector3 rayStart = box.transform.TransformPoint(localSample + new Vector3(0f, 20f, 0f));

                if (Physics.Raycast(rayStart, Vector3.down, out RaycastHit hit, 300f, groundLayer, QueryTriggerInteraction.Ignore))
                {
                    Vector3 centerPos = hit.point + spawnOffset;

                    // avoid dropping a row right on top of something
                    if (Physics.CheckSphere(centerPos, minDistance, LayerMask.GetMask("Default", "Obstacle")))
                        continue;

                    SpawnCoinRow(centerPos, box.transform);
                }
            }
        }
    }

    private void SpawnCoinRow(Vector3 centerPos, Transform areaTransform)
    {
        Vector3 forward = areaTransform.forward.normalized;
        Vector3 right   = areaTransform.right.normalized;

        // random curve per row
        float curveAmplitude = Random.Range(minCurveAmplitude, maxCurveAmplitude);

        float totalLength = (coinsPerRow - 1) * distanceBetweenCoins;
        float startOffset = -totalLength * 0.5f; // center the row on the spawn point

        for (int i = 0; i < coinsPerRow; i++)
        {
            float forwardOffset = startOffset + i * distanceBetweenCoins;
            float t = coinsPerRow > 1 ? (float)i / (coinsPerRow - 1) : 0f;

            // sin curve from middle: 0 -> 1 -> 0
            float sidewaysOffset = Mathf.Sin(t * Mathf.PI) * curveAmplitude;

            Vector3 samplePos = centerPos + forward * forwardOffset + right * sidewaysOffset + Vector3.up * 2f;

            if (Physics.Raycast(samplePos, Vector3.down, out RaycastHit hit, 20f, groundLayer, QueryTriggerInteraction.Ignore))
            {
                Vector3 finalPos = hit.point + spawnOffset;

                if (Physics.CheckSphere(finalPos, 0.3f, LayerMask.GetMask("Default", "Obstacle")))
                    continue;

            GameObject coin = Instantiate(coinPrefab, finalPos, Quaternion.identity, coinFolder);

            // base rotation: stand the coin straight up
            Quaternion baseRot = Quaternion.identity; // world-up

            // apply extra rotation from inspector so you can fix orientation
            coin.transform.rotation = baseRot * Quaternion.Euler(coinRotationOffsetEuler);

            }
        }
    }
}
