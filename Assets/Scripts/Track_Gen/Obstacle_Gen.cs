using UnityEngine;
using System.Collections;

public class ObstacleSpawner : MonoBehaviour
{
    [Header("障碍物预制体")]
    public GameObject[] obstaclePrefabs;

    [Header("生成设置")]
    [Range(0f, 1f)] public float spawnProbability = 0.35f;
    public float minDistance = 4f;
    public float gridSpacing = 5f;
    public LayerMask groundLayer;
    public Vector3 spawnOffset = new Vector3(0f, 0.1f, 0f);

    private bool hasSpawned = false;
    private Transform obstacleFolder;

    private void OnEnable()
    {
        if (!hasSpawned)
            StartCoroutine(SpawnRoutine());
    }

    private IEnumerator SpawnRoutine()
    {
        hasSpawned = true;

        yield return null;

        if (obstaclePrefabs == null || obstaclePrefabs.Length == 0)
        {
            Debug.LogWarning($"[ObstacleSpawner] {name} 没有配置 obstaclePrefabs，跳过生成。");
            yield break;
        }

        if (obstacleFolder == null)
        {
            obstacleFolder = new GameObject("Obstacles_AutoGenerated").transform;
            obstacleFolder.SetParent(transform, false);
        }

        foreach (Transform child in transform)
        {
            if (!child.name.StartsWith("ObstacleArea")) continue;
            if (!child.TryGetComponent<BoxCollider>(out var box)) continue;

            GenerateInArea_Local(box);
        }
    }

    private void GenerateInArea_Local(BoxCollider box)
    {
        Vector3 size = box.size;
        Vector3 center = box.center;

        int stepsX = Mathf.Max(1, Mathf.CeilToInt(size.x / gridSpacing));
        int stepsZ = Mathf.Max(1, Mathf.CeilToInt(size.z / gridSpacing));

        Vector3 localMin = center - size * 0.5f;

        for (int x = 0; x < stepsX; x++)
        {
            for (int z = 0; z < stepsZ; z++)
            {
                if (Random.value > spawnProbability) continue;

                float offsetX = (x + 0.5f + Random.Range(-0.4f, 0.4f)) * size.x / stepsX;
                float offsetZ = (z + 0.5f + Random.Range(-0.4f, 0.4f)) * size.z / stepsZ;

                Vector3 localSample = localMin + new Vector3(offsetX, 0f, offsetZ);
                Vector3 rayStart = box.transform.TransformPoint(localSample + new Vector3(0f, 20f, 0f));
                if (Physics.Raycast(rayStart, Vector3.down, out RaycastHit hit, 300f, groundLayer, QueryTriggerInteraction.Ignore))
                {
                    Vector3 pos = hit.point + spawnOffset;

                    if (Physics.CheckSphere(pos, minDistance, LayerMask.GetMask("Default", "Obstacle")))
                        continue;

                    GameObject prefab = obstaclePrefabs[Random.Range(0, obstaclePrefabs.Length)];

                    var obj = Instantiate(prefab, pos, Quaternion.identity, obstacleFolder);
                    obj.tag = "Obstacle";
                    obj.transform.rotation = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
                }
            }
        }
    }
}
